/*
 * generated by Xtext 2.25.0
 */
package org.xtext.jsonProject.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.jsonProject.jsonProject.ArrayObject;
import org.xtext.jsonProject.jsonProject.BooleanObject;
import org.xtext.jsonProject.jsonProject.Initialisation;
import org.xtext.jsonProject.jsonProject.Insert;
import org.xtext.jsonProject.jsonProject.JsonCommand;
import org.xtext.jsonProject.jsonProject.JsonCommands;
import org.xtext.jsonProject.jsonProject.JsonEntries;
import org.xtext.jsonProject.jsonProject.JsonEntry;
import org.xtext.jsonProject.jsonProject.JsonPrimitive;
import org.xtext.jsonProject.jsonProject.JsonProjectPackage;
import org.xtext.jsonProject.jsonProject.Modify;
import org.xtext.jsonProject.jsonProject.Mult;
import org.xtext.jsonProject.jsonProject.Path;
import org.xtext.jsonProject.jsonProject.Print;
import org.xtext.jsonProject.jsonProject.Remove;
import org.xtext.jsonProject.jsonProject.Select;
import org.xtext.jsonProject.jsonProject.Store;
import org.xtext.jsonProject.jsonProject.StringObject;
import org.xtext.jsonProject.jsonProject.Sum;
import org.xtext.jsonProject.services.JsonProjectGrammarAccess;

@SuppressWarnings("all")
public class JsonProjectSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JsonProjectGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JsonProjectPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JsonProjectPackage.ARRAY_OBJECT:
				sequence_ArrayObject(context, (ArrayObject) semanticObject); 
				return; 
			case JsonProjectPackage.BOOLEAN_OBJECT:
				sequence_BooleanObject(context, (BooleanObject) semanticObject); 
				return; 
			case JsonProjectPackage.INITIALISATION:
				sequence_Initialisation(context, (Initialisation) semanticObject); 
				return; 
			case JsonProjectPackage.INSERT:
				sequence_Insert(context, (Insert) semanticObject); 
				return; 
			case JsonProjectPackage.JSON_COMMAND:
				sequence_JsonCommand(context, (JsonCommand) semanticObject); 
				return; 
			case JsonProjectPackage.JSON_COMMANDS:
				sequence_JsonCommands(context, (JsonCommands) semanticObject); 
				return; 
			case JsonProjectPackage.JSON_ENTRIES:
				sequence_JsonEntries(context, (JsonEntries) semanticObject); 
				return; 
			case JsonProjectPackage.JSON_ENTRY:
				sequence_JsonEntry(context, (JsonEntry) semanticObject); 
				return; 
			case JsonProjectPackage.JSON_PRIMITIVE:
				sequence_JsonPrimitive(context, (JsonPrimitive) semanticObject); 
				return; 
			case JsonProjectPackage.MODIFY:
				sequence_Modify(context, (Modify) semanticObject); 
				return; 
			case JsonProjectPackage.MULT:
				sequence_Mult(context, (Mult) semanticObject); 
				return; 
			case JsonProjectPackage.PATH:
				sequence_Path(context, (Path) semanticObject); 
				return; 
			case JsonProjectPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case JsonProjectPackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case JsonProjectPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case JsonProjectPackage.STORE:
				sequence_Store(context, (Store) semanticObject); 
				return; 
			case JsonProjectPackage.STRING_OBJECT:
				sequence_StringObject(context, (StringObject) semanticObject); 
				return; 
			case JsonProjectPackage.SUM:
				sequence_Sum(context, (Sum) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     JsonObject returns ArrayObject
	 *     JsonPrimitive returns ArrayObject
	 *     ArrayObject returns ArrayObject
	 *
	 * Constraint:
	 *     (values+=JsonObject values+=JsonObject*)?
	 */
	protected void sequence_ArrayObject(ISerializationContext context, ArrayObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonObject returns BooleanObject
	 *     JsonPrimitive returns BooleanObject
	 *     BooleanObject returns BooleanObject
	 *
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_BooleanObject(ISerializationContext context, BooleanObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.BOOLEAN_OBJECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.BOOLEAN_OBJECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanObjectAccess().getValueBooleanEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Initialisation returns Initialisation
	 *
	 * Constraint:
	 *     filePath=STRING
	 */
	protected void sequence_Initialisation(ISerializationContext context, Initialisation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.INITIALISATION__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.INITIALISATION__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialisationAccess().getFilePathSTRINGTerminalRuleCall_1_0(), semanticObject.getFilePath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Insert
	 *     Insert returns Insert
	 *
	 * Constraint:
	 *     (jsonObject=JsonObject path=Path?)
	 */
	protected void sequence_Insert(ISerializationContext context, Insert semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonCommand returns JsonCommand
	 *
	 * Constraint:
	 *     (init=Initialisation operations+=Operation* final=Final)
	 */
	protected void sequence_JsonCommand(ISerializationContext context, JsonCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonCommands returns JsonCommands
	 *
	 * Constraint:
	 *     jsonCommands+=JsonCommand+
	 */
	protected void sequence_JsonCommands(ISerializationContext context, JsonCommands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonObject returns JsonEntries
	 *     JsonEntries returns JsonEntries
	 *
	 * Constraint:
	 *     (listEntries+=JsonEntry listEntries+=JsonEntry*)
	 */
	protected void sequence_JsonEntries(ISerializationContext context, JsonEntries semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonEntry returns JsonEntry
	 *
	 * Constraint:
	 *     (key=ID jsonObject=JsonObject)
	 */
	protected void sequence_JsonEntry(ISerializationContext context, JsonEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.JSON_ENTRY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.JSON_ENTRY__KEY));
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.JSON_ENTRY__JSON_OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.JSON_ENTRY__JSON_OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonEntryAccess().getKeyIDTerminalRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getJsonEntryAccess().getJsonObjectJsonObjectParserRuleCall_4_0(), semanticObject.getJsonObject());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonObject returns JsonPrimitive
	 *     JsonPrimitive returns JsonPrimitive
	 *
	 * Constraint:
	 *     {JsonPrimitive}
	 */
	protected void sequence_JsonPrimitive(ISerializationContext context, JsonPrimitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Modify
	 *     Modify returns Modify
	 *
	 * Constraint:
	 *     (path=Path? jsonObject=JsonObject)
	 */
	protected void sequence_Modify(ISerializationContext context, Modify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Mult
	 *     Mult returns Mult
	 *
	 * Constraint:
	 *     (pathTOStore=Path pathToMult=Path)
	 */
	protected void sequence_Mult(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.MULT__PATH_TO_STORE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.MULT__PATH_TO_STORE));
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.MULT__PATH_TO_MULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.MULT__PATH_TO_MULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultAccess().getPathTOStorePathParserRuleCall_1_0(), semanticObject.getPathTOStore());
		feeder.accept(grammarAccess.getMultAccess().getPathToMultPathParserRuleCall_2_0(), semanticObject.getPathToMult());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Path returns Path
	 *
	 * Constraint:
	 *     (values+=ID? values+=ID*)
	 */
	protected void sequence_Path(ISerializationContext context, Path semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Final returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     path=Path?
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     path=Path?
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Select
	 *     Select returns Select
	 *
	 * Constraint:
	 *     path=Path
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.SELECT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.SELECT__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectAccess().getPathPathParserRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Final returns Store
	 *     Store returns Store
	 *
	 * Constraint:
	 *     (path=Path? filePath=STRING)
	 */
	protected void sequence_Store(ISerializationContext context, Store semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonObject returns StringObject
	 *     JsonPrimitive returns StringObject
	 *     StringObject returns StringObject
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringObject(ISerializationContext context, StringObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.STRING_OBJECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.STRING_OBJECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringObjectAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Sum
	 *     Sum returns Sum
	 *
	 * Constraint:
	 *     (pathTOStore=Path pathToAdd=Path)
	 */
	protected void sequence_Sum(ISerializationContext context, Sum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.SUM__PATH_TO_STORE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.SUM__PATH_TO_STORE));
			if (transientValues.isValueTransient(semanticObject, JsonProjectPackage.Literals.SUM__PATH_TO_ADD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonProjectPackage.Literals.SUM__PATH_TO_ADD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getPathTOStorePathParserRuleCall_1_0(), semanticObject.getPathTOStore());
		feeder.accept(grammarAccess.getSumAccess().getPathToAddPathParserRuleCall_2_0(), semanticObject.getPathToAdd());
		feeder.finish();
	}
	
	
}
